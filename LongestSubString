// Day -3
// Longest Substring Without Repeating Characters
// Method: Sliding Window with HashSet
//
// Use two pointers, `left` and `right`, to create a dynamic window that expands to include
// unique characters and shrinks when a duplicate is found.
// A HashSet is used to store the characters currently in the window.
// - If the character at `right` is not in the set, add it and update the max length.
// - If it is already in the set, move the `left` pointer forward and remove characters
//   until the duplicate is gone.
// This approach ensures each character is processed at most twice (added and removed),
// giving an efficient O(n) time complexity.
//
// Time Complexity: O(n)
// Space Complexity: O(min(n, m)) → where m is the character set size (e.g., 26 for lowercase, 128 for ASCII)
//You use two pointers:
//how to implement sliding window
// left (👈 where the window starts)
// right (👉 where the window ends)

// You expand the window by moving right ➡️

// You shrink the window by moving left ➡️ when needed (e.g. if there's a repeat)

// You check or update something inside the window — like the sum, max length, or count

public int lengthOfLongestSubstring(String s) {
    Set<Character> seen = new HashSet<>();
    int left = 0, right = 0, maxLen = 0;

    while (right < s.length()) {
        char currentChar = s.charAt(right);
        while (seen.contains(currentChar)) {
            seen.remove(s.charAt(left));
            left++;
        }
        seen.add(currentChar);
        maxLen = Math.max(maxLen, right - left + 1);
        right++;
    }

    return maxLen;
}
